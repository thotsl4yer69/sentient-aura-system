<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sentient Core</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            cursor: pointer;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            max-width: 350px;
            pointer-events: none;
            line-height: 1.6;
        }
        #info .label {
            color: #888;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        #info .value {
            color: #0ff;
            font-weight: bold;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #888;
            font-family: 'Inter', sans-serif;
            font-size: 11px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
            pointer-events: none;
            text-align: right;
        }
        #mode-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #0ff;
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            pointer-events: none;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info">
        <b>SENTIENT CORE</b><br>
        <span class="label">Status:</span> <span class="value">Initializing...</span>
    </div>

    <div id="mode-indicator">INITIALIZING</div>

    <div id="controls">
        <b>CONTROLS</b><br>
        Drag: Rotate • Scroll: Zoom<br>
        Space: Reconnect • H: Toggle Help
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, particles, controls;
        let uniforms;
        const infoDiv = document.getElementById('info');
        const modeIndicator = document.getElementById('mode-indicator');

        // --- VISUALIZATION MODES ---
        const MODES = {
            HUMANOID: 0,        // Communication (Cortana-like avatar)
            SPATIAL: 1,         // Room mapping (camera FOV + objects)
            RF_SPECTRUM: 2,     // Radio frequency visualization
            NEURAL_NETWORK: 3,  // Processing/thinking visualization
            ACTION_SPACE: 4     // Executing/tool interaction
        };

        let currentMode = MODES.HUMANOID;
        let targetMode = MODES.HUMANOID;

        const mouse = new THREE.Vector2(-10, -10);

        // --- Mode Colors ---
        const MODE_COLORS = {
            [MODES.HUMANOID]: new THREE.Color(0xff8800),        // Orange (warm, approachable)
            [MODES.SPATIAL]: new THREE.Color(0x0088ff),         // Blue (perception)
            [MODES.RF_SPECTRUM]: new THREE.Color(0xff0000),     // Red (alert/defense)
            [MODES.NEURAL_NETWORK]: new THREE.Color(0x00ff88), // Green (processing)
            [MODES.ACTION_SPACE]: new THREE.Color(0x8800ff)    // Purple (action)
        };

        let targetColor = MODE_COLORS[MODES.HUMANOID];

        let ws;

        // Binary protocol decoder for efficient particle data transmission
        function decodeBinaryParticles(arrayBuffer) {
            // Binary protocol structure (from binary_protocol.py):
            // Header: 64 bytes
            // Payload: 120KB (10,000 particles × 3 coordinates × 4 bytes float32)

            const HEADER_SIZE = 64;
            const view = new DataView(arrayBuffer);

            // Decode header (little-endian)
            const version = view.getUint8(0);
            const msgType = view.getUint8(1);
            const frameId = view.getUint32(2, true);
            const timestampMs = view.getBigUint64(6, true);
            const particleCount = view.getUint32(14, true);
            const fps = view.getFloat32(18, true);
            const inferenceMs = view.getFloat32(22, true);
            const totalMs = view.getFloat32(26, true);

            // Decode particle positions
            const payload = new Float32Array(arrayBuffer, HEADER_SIZE);

            return {
                metadata: {
                    version,
                    msgType,
                    frameId,
                    timestampMs: Number(timestampMs),
                    particleCount,
                    fps,
                    inferenceMs,
                    totalMs
                },
                particles: payload  // Float32Array of [x,y,z, x,y,z, ...]
            };
        }

        function connectWebSocket() {
            ws = new WebSocket("ws://localhost:8765");
            ws.binaryType = 'arraybuffer';  // IMPORTANT: Receive binary data

            ws.onopen = () => {
                console.log("WebSocket connection established (binary mode)");
                infoDiv.innerHTML = "<b>SENTIENT CORE</b><br>Connected to Core (Binary Protocol)";
            };

            ws.onmessage = (event) => {
                // Handle both binary (particle data) and JSON (state updates)
                if (event.data instanceof ArrayBuffer) {
                    // Binary message - decode particle positions
                    const decoded = decodeBinaryParticles(event.data);
                    console.log(`Binary particles received: ${decoded.metadata.particleCount} particles, ` +
                                `FPS=${decoded.metadata.fps.toFixed(1)}, ` +
                                `Inference=${decoded.metadata.inferenceMs.toFixed(2)}ms`);
                    handleBinaryParticles(decoded);
                } else {
                    // JSON message - handle state updates (fallback)
                    const message = JSON.parse(event.data);
                    console.log("JSON message received:", message);
                    handleWebSocketMessage(message);
                }
            };

            ws.onclose = () => {
                console.log("WebSocket connection closed. Reconnecting...");
                infoDiv.innerHTML = "<b>SENTIENT CORE</b><br>Connection lost. Reconnecting...";
                setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = (error) => {
                console.error("WebSocket error:", error);
            };
        }

        // Sensor and visualization data
        let sensorData = {
            temperature: null,
            humidity: null,
            motion: false,
            audioLevel: 0.0,
            activeDaemons: [],
            objectsDetected: 0,
            detectedObjects: [],  // Array of {x, y, z, label, confidence}
            cameraFOV: 90,        // Camera field of view
            flipperRF: [],        // Array of {frequency, strength, protocol}
            flipperActive: false
        };

        // AI Self-Representation Parameters (dynamic, AI-controlled)
        let aiAppearance = {
            description: null,
            parameters: {
                head_percentage: 0.35,
                torso_percentage: 0.30,
                aura_percentage: 0.20,
                flow_percentage: 0.15,
                primary_color: [0.4, 0.6, 1.0],
                accent_color: [0.8, 0.4, 1.0],
                energy_pattern: 'orbital',
                density_profile: 'ethereal',
                complexity: 0.7
            },
            timestamp: null,
            version: 0
        };

        // ========================================
        // INPUT VALIDATION & SECURITY
        // ========================================

        const VALID_STATES = ['idle', 'listening', 'processing', 'speaking', 'executing', 'threat_alert'];
        const VALID_MESSAGE_TYPES = ['state_update', 'sensor_data', 'command', 'error', 'appearance_definition'];

        function validateNumber(value, min, max) {
            return typeof value === 'number' && !isNaN(value) && value >= min && value <= max;
        }

        function validateString(value, allowedValues = null) {
            if (typeof value !== 'string') return false;
            if (allowedValues && !allowedValues.includes(value)) return false;
            return value.length < 1000; // Prevent enormous strings
        }

        function validateObject(obj) {
            return obj !== null && typeof obj === 'object' && !Array.isArray(obj);
        }

        function validateArray(arr, maxLength = 100) {
            return Array.isArray(arr) && arr.length <= maxLength;
        }

        function validateMessage(message) {
            if (!validateObject(message)) {
                console.error("Invalid message: not an object");
                return false;
            }

            // Validate message type
            if (!validateString(message.type, VALID_MESSAGE_TYPES)) {
                console.error("Invalid message type:", message.type);
                return false;
            }

            // For state_update messages
            if (message.type === 'state_update') {
                if (!validateString(message.state, VALID_STATES)) {
                    console.error("Invalid state:", message.state);
                    return false;
                }

                // Validate world_state if present
                if (message.world_state !== undefined) {
                    if (!validateObject(message.world_state)) {
                        console.error("Invalid world_state: not an object");
                        return false;
                    }

                    const ws = message.world_state;

                    // Validate environment data
                    if (ws.environment !== undefined) {
                        if (!validateObject(ws.environment)) return false;
                        if (ws.environment.temperature !== undefined && ws.environment.temperature !== null) {
                            if (!validateNumber(ws.environment.temperature, -50, 100)) {
                                console.error("Invalid temperature:", ws.environment.temperature);
                                return false;
                            }
                        }
                        if (ws.environment.humidity !== undefined && ws.environment.humidity !== null) {
                            if (!validateNumber(ws.environment.humidity, 0, 100)) {
                                console.error("Invalid humidity:", ws.environment.humidity);
                                return false;
                            }
                        }
                    }

                    // Validate vision data
                    if (ws.vision !== undefined) {
                        if (!validateObject(ws.vision)) return false;
                        if (ws.vision.detected_objects !== undefined) {
                            if (!validateArray(ws.vision.detected_objects, 50)) {
                                console.error("Invalid detected_objects array");
                                return false;
                            }
                            // Validate each object
                            for (const obj of ws.vision.detected_objects) {
                                if (!validateObject(obj)) return false;
                                if (!validateString(obj.label)) return false;
                                if (obj.confidence !== undefined && !validateNumber(obj.confidence, 0, 1)) {
                                    return false;
                                }
                                if (obj.box !== undefined && !validateObject(obj.box)) return false;
                            }
                        }
                    }

                    // Validate audio data
                    if (ws.audio !== undefined) {
                        if (!validateObject(ws.audio)) return false;
                        if (ws.audio.ambient_noise_level !== undefined) {
                            if (!validateNumber(ws.audio.ambient_noise_level, 0, 1)) {
                                console.error("Invalid audio level:", ws.audio.ambient_noise_level);
                                return false;
                            }
                        }
                    }

                    // Validate Flipper data
                    if (ws.flipper !== undefined) {
                        if (!validateObject(ws.flipper)) return false;
                        if (ws.flipper.rf_scan !== undefined) {
                            if (!validateArray(ws.flipper.rf_scan, 100)) {
                                console.error("Invalid rf_scan array");
                                return false;
                            }
                            // Validate each RF scan entry
                            for (const rf of ws.flipper.rf_scan) {
                                if (!validateObject(rf)) return false;
                                if (rf.frequency !== undefined && !validateNumber(rf.frequency, 0, 10000)) {
                                    return false;
                                }
                                if (rf.strength !== undefined && !validateNumber(rf.strength, 0, 1)) {
                                    return false;
                                }
                            }
                        }
                    }

                    // Validate system data
                    if (ws.system !== undefined) {
                        if (!validateObject(ws.system)) return false;
                        if (ws.system.active_daemons !== undefined) {
                            if (!validateArray(ws.system.active_daemons, 20)) {
                                return false;
                            }
                        }
                    }
                }
            }

            return true;
        }

        // Handle binary particle data from Coral TPU
        function handleBinaryParticles(decoded) {
            const { metadata, particles: particleData } = decoded;

            // Update particle positions directly from Coral TPU output
            // 'particles' is the global THREE.Points object, 'particleData' is the decoded Float32Array
            if (particles && particles.geometry) {
                const positionAttribute = particles.geometry.getAttribute('position');

                // Copy decoded particle positions to geometry
                // Decoded particles are already Float32Array[x,y,z, x,y,z, ...]
                if (positionAttribute && particleData.length === positionAttribute.array.length) {
                    positionAttribute.array.set(particleData);
                    positionAttribute.needsUpdate = true;
                } else {
                    console.warn(`Particle count mismatch: received ${particleData.length/3}, expected ${positionAttribute.array.length/3}`);
                }
            }

            // Update info display with real-time metrics
            let infoHTML = '<b>SENTIENT CORE</b><br>';
            infoHTML += '<span class="label">Protocol:</span> <span class="value">BINARY</span><br>';
            infoHTML += `<span class="label">FPS:</span> <span class="value">${metadata.fps.toFixed(1)}</span><br>`;
            infoHTML += `<span class="label">Inference:</span> <span class="value">${metadata.inferenceMs.toFixed(2)}ms</span><br>`;
            infoHTML += `<span class="label">Frame:</span> <span class="value">${metadata.frameId}</span><br>`;
            infoHTML += `<span class="label">Particles:</span> <span class="value">${metadata.particleCount.toLocaleString()}</span><br>`;
            infoHTML += `<span class="label">Total:</span> <span class="value">${metadata.totalMs.toFixed(2)}ms</span><br>`;
            infoDiv.innerHTML = infoHTML;

            modeIndicator.textContent = `CORAL TPU - ${metadata.fps.toFixed(1)} FPS`;
        }

        function handleWebSocketMessage(message) {
            console.log("Handling message:", message);

            // SECURITY: Validate message before processing
            if (!validateMessage(message)) {
                console.error("Message validation failed, ignoring message");
                return;
            }

            if (message.type === 'state_update') {
                console.log("State update received:", message.state);

                // --- STATE TO MODE MAPPING ---
                if (message.state === 'speaking') {
                    targetMode = MODES.HUMANOID;
                    targetColor = MODE_COLORS[MODES.HUMANOID];
                    modeIndicator.textContent = 'COMMUNICATION';
                } else if (message.state === 'listening' || message.state === 'idle') {
                    // Use SPATIAL if camera data available, otherwise HUMANOID
                    if (sensorData.detectedObjects.length > 0) {
                        targetMode = MODES.SPATIAL;
                        targetColor = MODE_COLORS[MODES.SPATIAL];
                        modeIndicator.textContent = 'SPATIAL MAPPING';
                    } else {
                        targetMode = MODES.HUMANOID;
                        targetColor = MODE_COLORS[MODES.HUMANOID];
                        modeIndicator.textContent = 'LISTENING';
                    }
                } else if (message.state === 'processing') {
                    targetMode = MODES.NEURAL_NETWORK;
                    targetColor = MODE_COLORS[MODES.NEURAL_NETWORK];
                    modeIndicator.textContent = 'PROCESSING';
                } else if (message.state === 'executing') {
                    targetMode = MODES.ACTION_SPACE;
                    targetColor = MODE_COLORS[MODES.ACTION_SPACE];
                    modeIndicator.textContent = 'EXECUTING';
                } else if (message.state === 'threat_alert') {
                    // Use RF_SPECTRUM if Flipper active, otherwise HUMANOID alert
                    if (sensorData.flipperActive) {
                        targetMode = MODES.RF_SPECTRUM;
                        targetColor = MODE_COLORS[MODES.RF_SPECTRUM];
                        modeIndicator.textContent = 'RF DEFENSE';
                    } else {
                        targetMode = MODES.HUMANOID;
                        targetColor = MODE_COLORS[MODES.RF_SPECTRUM];
                        modeIndicator.textContent = 'THREAT ALERT';
                    }
                }

                // Extract sensor data from world_state
                if (message.world_state) {
                    const ws = message.world_state;

                    // Environment sensors
                    if (ws.environment) {
                        sensorData.temperature = ws.environment.temperature;
                        sensorData.humidity = ws.environment.humidity;
                    }

                    // Vision data
                    if (ws.vision) {
                        sensorData.motion = ws.vision.motion_detected || false;
                        sensorData.objectsDetected = (ws.vision.detected_objects || []).length;
                        sensorData.detectedObjects = ws.vision.detected_objects || [];
                        // detectedObjects format: [{label, confidence, box: {x, y, w, h}}]
                        // We'll convert to 3D positions in updateSpatialTargets()
                    }

                    // Audio data
                    if (ws.audio) {
                        sensorData.audioLevel = ws.audio.ambient_noise_level || 0.0;
                    }

                    // Flipper RF data
                    if (ws.flipper) {
                        sensorData.flipperActive = ws.flipper.status === 'active' || false;
                        sensorData.flipperRF = ws.flipper.rf_scan || [];
                        // rf_scan format: [{frequency, strength, protocol}]
                    }

                    // System/active daemons
                    if (ws.system) {
                        sensorData.activeDaemons = ws.system.active_daemons || [];
                    }

                    console.log("Sensor data updated:", sensorData);
                }

                // Update info display
                let infoHTML = '<b>SENTIENT CORE</b><br>';
                infoHTML += `<span class="label">State:</span> <span class="value">${message.state.toUpperCase()}</span><br>`;

                if (message.text) {
                    infoHTML += `<span class="label">Status:</span> ${message.text}<br>`;
                }

                // Show sensor data if available
                if (message.world_state) {
                    infoHTML += '<br><span class="label">— SENSORS —</span><br>';

                    if (sensorData.temperature !== null) {
                        infoHTML += `<span class="label">Temperature:</span> <span class="value">${sensorData.temperature.toFixed(1)}°C</span><br>`;
                    }
                    if (sensorData.humidity !== null) {
                        infoHTML += `<span class="label">Humidity:</span> <span class="value">${sensorData.humidity.toFixed(1)}%</span><br>`;
                    }
                    if (sensorData.audioLevel > 0) {
                        infoHTML += `<span class="label">Audio:</span> <span class="value">${(sensorData.audioLevel * 100).toFixed(0)}%</span><br>`;
                    }
                    if (sensorData.motion) {
                        infoHTML += `<span class="label">Motion:</span> <span class="value">DETECTED</span><br>`;
                    }
                    if (sensorData.objectsDetected > 0) {
                        infoHTML += `<span class="label">Objects:</span> <span class="value">${sensorData.objectsDetected}</span><br>`;
                    }
                    if (sensorData.flipperActive) {
                        infoHTML += `<span class="label">Flipper:</span> <span class="value">ACTIVE</span><br>`;
                    }

                    if (sensorData.activeDaemons.length > 0) {
                        infoHTML += `<br><span class="label">Active Daemons:</span><br>`;
                        sensorData.activeDaemons.forEach(daemon => {
                            infoHTML += `<span class="value">• ${daemon}</span><br>`;
                        });
                    }
                }

                infoDiv.innerHTML = infoHTML;
            } else if (message.type === 'appearance_definition') {
                // AI has decided how it wants to appear
                console.log("AI appearance definition received:", message);

                if (message.description) {
                    aiAppearance.description = message.description;
                    console.log(`AI self-description: "${message.description}"`);
                }

                if (message.parameters) {
                    // Update AI appearance parameters
                    aiAppearance.parameters = {
                        ...aiAppearance.parameters,
                        ...message.parameters
                    };
                    aiAppearance.timestamp = message.timestamp || Date.now();
                    aiAppearance.version += 1;

                    console.log("AI appearance parameters updated:", aiAppearance.parameters);

                    // Regenerate humanoid formation with new AI-defined parameters
                    if (currentMode === MODES.HUMANOID || targetMode === MODES.HUMANOID) {
                        console.log("Regenerating humanoid form with AI-defined appearance...");
                        const newPositions = generateHumanoidFormation(particles.geometry.attributes.position.count);
                        particles.geometry.attributes.position.array.set(newPositions);
                        particles.geometry.attributes.position.needsUpdate = true;

                        // Update color if AI specified one
                        if (message.parameters.primary_color) {
                            const [r, g, b] = message.parameters.primary_color;
                            targetColor = new THREE.Color(r, g, b);
                            console.log(`AI chose primary color: rgb(${r}, ${g}, ${b})`);
                        }
                    }

                    // Show AI's description in info panel
                    if (message.description) {
                        const descDiv = document.createElement('div');
                        descDiv.style.cssText = 'position:absolute; top:100px; left:20px; background:rgba(0,0,0,0.8); padding:15px; border-radius:10px; max-width:400px; color:#fff; font-family:Inter,sans-serif; font-size:14px; line-height:1.5;';
                        descDiv.innerHTML = `<b>AI Self-Description:</b><br>"${message.description}"`;
                        document.body.appendChild(descDiv);

                        // Remove after 10 seconds
                        setTimeout(() => descDiv.remove(), 10000);
                    }
                }
            }
        }

        // ========================================
        // PROCEDURAL PARTICLE POSITION GENERATORS
        // ========================================

        function generateHumanoidFormation(particleCount) {
            // AI-defined appearance - the AI controls its own visual form
            const positions = new Float32Array(particleCount * 3);

            // Get AI-defined proportions (or use defaults if not yet defined)
            const params = aiAppearance.parameters;
            const headPct = params.head_percentage || 0.35;
            const torsoPct = params.torso_percentage || 0.30;
            const auraPct = params.aura_percentage || 0.20;
            const flowPct = params.flow_percentage || 0.15;

            // Anatomical anchor points
            const headCenter = new THREE.Vector3(0, 1.65, 0);
            const neckBase = new THREE.Vector3(0, 1.45, 0);
            const shoulderCenter = new THREE.Vector3(0, 1.35, 0);
            const torsoCenter = new THREE.Vector3(0, 1.0, 0);
            const hipCenter = new THREE.Vector3(0, 0.75, 0);

            // Calculate cumulative thresholds for particle distribution
            const threshold_head = headPct;
            const threshold_torso = headPct + torsoPct;
            const threshold_aura = threshold_torso + auraPct;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const rand = Math.random();

                if (rand < threshold_head) {
                    // HEAD & FACE - AI-defined percentage
                    // More particles in front (face) than back
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;

                    // Egg-shaped head (wider at top, narrower at chin)
                    const verticalPos = Math.cos(phi);
                    const headRadius = 0.14 * (1.0 - verticalPos * 0.15);

                    const r = headRadius * Math.cbrt(Math.random());

                    let x = headCenter.x + r * Math.sin(phi) * Math.cos(theta);
                    let y = headCenter.y + r * verticalPos;
                    let z = headCenter.z + r * Math.sin(phi) * Math.sin(theta);

                    // Add more density to front (face features)
                    if (z > headCenter.z) {
                        // Front of face - add facial feature hints
                        const faceT = (y - headCenter.y + 0.1) / 0.2; // Normalize face height

                        // Eyes region (more particles)
                        if (faceT > 0.3 && faceT < 0.6 && Math.abs(x) > 0.03 && Math.abs(x) < 0.09) {
                            // Dense eye regions
                            positions[i3 + 0] = x;
                            positions[i3 + 1] = y;
                            positions[i3 + 2] = z + Math.random() * 0.02; // Slight forward projection
                            continue;
                        }
                    }

                    positions[i3 + 0] = x;
                    positions[i3 + 1] = y;
                    positions[i3 + 2] = z;

                } else if (rand < threshold_torso) {
                    // TORSO - AI-defined percentage
                    const t = Math.random();
                    const angle = Math.random() * Math.PI * 2;

                    // Blend from neck to shoulders
                    const blendY = neckBase.y + (shoulderCenter.y - neckBase.y) * t;
                    const radius = 0.05 + (0.22 * t); // Narrow neck expanding to shoulders

                    positions[i3 + 0] = radius * Math.cos(angle);
                    positions[i3 + 1] = blendY;
                    positions[i3 + 2] = radius * Math.sin(angle);

                } else if (rand < threshold_aura) {
                    // ENERGY AURA - AI-defined percentage
                    // Energy pattern determined by AI (orbital, flowing, radial)
                    const energyPattern = params.energy_pattern || 'orbital';

                    if (energyPattern === 'orbital') {
                        // Orbital energy - particles circle around the form
                        const orbitAngle = Math.random() * Math.PI * 2;
                        const orbitHeight = 0.8 + Math.random() * 0.9;
                        const orbitRadius = 0.3 + Math.random() * 0.2;
                        const spiralOffset = Math.sin(orbitHeight * Math.PI * 3) * 0.1;

                        positions[i3 + 0] = (orbitRadius + spiralOffset) * Math.cos(orbitAngle);
                        positions[i3 + 1] = orbitHeight;
                        positions[i3 + 2] = (orbitRadius + spiralOffset) * Math.sin(orbitAngle);
                    } else if (energyPattern === 'radial') {
                        // Radial energy - particles emanate outward from center
                        const angle = Math.random() * Math.PI * 2;
                        const phi = (Math.random() - 0.5) * Math.PI;
                        const radius = 0.3 + Math.random() * 0.3;

                        positions[i3 + 0] = radius * Math.cos(phi) * Math.cos(angle);
                        positions[i3 + 1] = 1.3 + radius * Math.sin(phi);
                        positions[i3 + 2] = radius * Math.cos(phi) * Math.sin(angle);
                    } else {
                        // Flowing energy - vertical streams
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 0.3 + Math.random() * 0.15;
                        const height = 0.5 + Math.random() * 1.5;
                        const waveOffset = Math.sin(height * Math.PI * 2) * 0.1;

                        positions[i3 + 0] = (radius + waveOffset) * Math.cos(angle);
                        positions[i3 + 1] = height;
                        positions[i3 + 2] = (radius + waveOffset) * Math.sin(angle);
                    }
                } else {
                    // FLOW PARTICLES - AI-defined percentage
                    // Ambient flowing particles around the entire form
                    const flowAngle = Math.random() * Math.PI * 2;
                    const flowRadius = 0.5 + Math.random() * 0.4;
                    const flowHeight = 0.3 + Math.random() * 1.8;

                    positions[i3 + 0] = flowRadius * Math.cos(flowAngle);
                    positions[i3 + 1] = flowHeight;
                    positions[i3 + 2] = flowRadius * Math.sin(flowAngle);
                }
            }

            return positions;
        }

        function generateSpatialMapFormation(particleCount) {
            // Create room space visualization
            // Particles map camera FOV cone + detected object positions
            const positions = new Float32Array(particleCount * 3);

            // Camera at origin looking forward (+Z)
            const cameraPos = new THREE.Vector3(0, 1.2, 0);
            const viewDistance = 5.0; // meters
            const fovRad = (sensorData.cameraFOV || 90) * Math.PI / 180;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const rand = Math.random();

                if (rand < 0.6 && sensorData.detectedObjects.length > 0) {
                    // 60% particles cluster around detected objects
                    const obj = sensorData.detectedObjects[Math.floor(Math.random() * sensorData.detectedObjects.length)];
                    // Convert 2D bounding box to 3D position (simple projection)
                    const objX = ((obj.box.x + obj.box.w/2) / 640 - 0.5) * 2; // Assuming 640px width
                    const objY = -((obj.box.y + obj.box.h/2) / 480 - 0.5) * 2; // Assuming 480px height
                    const objZ = 2.0 + Math.random() * 2.0; // Depth estimate

                    // Add scatter around object
                    const scatter = 0.3;
                    positions[i3 + 0] = cameraPos.x + objX + (Math.random() - 0.5) * scatter;
                    positions[i3 + 1] = cameraPos.y + objY + (Math.random() - 0.5) * scatter;
                    positions[i3 + 2] = cameraPos.z + objZ + (Math.random() - 0.5) * scatter;
                } else {
                    // 40% particles fill camera FOV cone
                    const depth = Math.random() * viewDistance;
                    const angle = (Math.random() - 0.5) * fovRad;
                    const height = (Math.random() - 0.5) * fovRad * 0.75; // Vertical FOV

                    positions[i3 + 0] = cameraPos.x + Math.sin(angle) * depth;
                    positions[i3 + 1] = cameraPos.y + Math.sin(height) * depth;
                    positions[i3 + 2] = cameraPos.z + Math.cos(angle) * depth;
                }
            }

            return positions;
        }

        function generateRFSpectrumFormation(particleCount) {
            // Visualize radio frequency spectrum as layered waves
            const positions = new Float32Array(particleCount * 3);

            // Create frequency spectrum visualization
            // Each frequency = horizontal layer with varying amplitude
            const freqCount = Math.max(1, sensorData.flipperRF.length);
            const layerHeight = 2.0 / freqCount;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                if (sensorData.flipperRF.length > 0) {
                    // Use actual RF scan data
                    const freqIdx = Math.floor(Math.random() * freqCount);
                    const rfData = sensorData.flipperRF[freqIdx];
                    const strength = rfData.strength || 0.5; // 0-1

                    const angle = Math.random() * Math.PI * 2;
                    const radius = 0.5 + strength * 1.5; // Stronger signal = wider radius
                    const y = -1.0 + layerHeight * freqIdx + (Math.random() - 0.5) * layerHeight * 0.5;

                    positions[i3 + 0] = radius * Math.cos(angle);
                    positions[i3 + 1] = y;
                    positions[i3 + 2] = radius * Math.sin(angle);
                } else {
                    // Fallback: generic wave pattern
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 0.5 + Math.random() * 1.5;
                    const y = (Math.random() - 0.5) * 2.0;

                    positions[i3 + 0] = radius * Math.cos(angle);
                    positions[i3 + 1] = y;
                    positions[i3 + 2] = radius * Math.sin(angle);
                }
            }

            return positions;
        }

        function generateNeuralNetworkFormation(particleCount) {
            // Neural network visualization - layered nodes with connections
            const positions = new Float32Array(particleCount * 3);

            const layers = 5;
            const nodesPerLayer = 20;
            const layerSpacing = 0.5;

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const rand = Math.random();

                if (rand < 0.7) {
                    // 70% particles form nodes
                    const layer = Math.floor(Math.random() * layers);
                    const node = Math.floor(Math.random() * nodesPerLayer);

                    const angleStep = (Math.PI * 2) / nodesPerLayer;
                    const angle = angleStep * node;
                    const radius = 0.8 + layer * 0.1;

                    const scatter = 0.05;
                    positions[i3 + 0] = radius * Math.cos(angle) + (Math.random() - 0.5) * scatter;
                    positions[i3 + 1] = 0.8 + (Math.random() - 0.5) * scatter;
                    positions[i3 + 2] = radius * Math.sin(angle) + layerSpacing * (layer - layers/2) + (Math.random() - 0.5) * scatter;
                } else {
                    // 30% particles form connections between nodes
                    const t = Math.random();
                    const layer1 = Math.floor(Math.random() * (layers - 1));
                    const layer2 = layer1 + 1;
                    const node1 = Math.floor(Math.random() * nodesPerLayer);
                    const node2 = Math.floor(Math.random() * nodesPerLayer);

                    const angleStep = (Math.PI * 2) / nodesPerLayer;
                    const angle1 = angleStep * node1;
                    const angle2 = angleStep * node2;
                    const radius1 = 0.8 + layer1 * 0.1;
                    const radius2 = 0.8 + layer2 * 0.1;

                    const x1 = radius1 * Math.cos(angle1);
                    const z1 = radius1 * Math.sin(angle1) + layerSpacing * (layer1 - layers/2);
                    const x2 = radius2 * Math.cos(angle2);
                    const z2 = radius2 * Math.sin(angle2) + layerSpacing * (layer2 - layers/2);

                    positions[i3 + 0] = x1 + (x2 - x1) * t;
                    positions[i3 + 1] = 0.8;
                    positions[i3 + 2] = z1 + (z2 - z1) * t;
                }
            }

            return positions;
        }

        function generateActionSpaceFormation(particleCount) {
            // Tool interaction visualization - particles form around action targets
            const positions = new Float32Array(particleCount * 3);

            // Create tool/object interaction space
            const toolPositions = [
                new THREE.Vector3(-0.5, 1.0, 1.0),  // Left tool
                new THREE.Vector3(0.5, 1.0, 1.0),   // Right tool
                new THREE.Vector3(0, 1.5, 0.5)      // Focus point
            ];

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;

                // Particles orbit around tool positions
                const tool = toolPositions[Math.floor(Math.random() * toolPositions.length)];
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 0.3;
                const radius = 0.2 + Math.random() * 0.3;

                positions[i3 + 0] = tool.x + radius * Math.cos(angle);
                positions[i3 + 1] = tool.y + height;
                positions[i3 + 2] = tool.z + radius * Math.sin(angle);
            }

            return positions;
        }

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 2.5;
            camera.position.y = 1;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.2;
            controls.target.set(0, 1.0, 0);

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('keydown', onKeyPress, false);

            connectWebSocket();

            createParticles();

            animate();
        }

        function createParticles() {
            const particleCount = 500000;

            // Generate all mode target positions
            const targetHumanoid = generateHumanoidFormation(particleCount);
            const targetSpatial = generateSpatialMapFormation(particleCount);
            const targetRF = generateRFSpectrumFormation(particleCount);
            const targetNeural = generateNeuralNetworkFormation(particleCount);
            const targetAction = generateActionSpaceFormation(particleCount);

            // Start positions (scattered sphere)
            const startPositions = new Float32Array(particleCount * 3);
            const randoms = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const r = 2 + Math.random() * 2;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                startPositions[i3 + 0] = r * Math.sin(theta) * Math.cos(phi);
                startPositions[i3 + 1] = (r * Math.sin(theta) * Math.sin(phi)) + 1.0;
                startPositions[i3 + 2] = r * Math.cos(theta);
                randoms[i] = Math.random();
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(startPositions, 3));
            geometry.setAttribute('aTargetHumanoid', new THREE.BufferAttribute(targetHumanoid, 3));
            geometry.setAttribute('aTargetSpatial', new THREE.BufferAttribute(targetSpatial, 3));
            geometry.setAttribute('aTargetRF', new THREE.BufferAttribute(targetRF, 3));
            geometry.setAttribute('aTargetNeural', new THREE.BufferAttribute(targetNeural, 3));
            geometry.setAttribute('aTargetAction', new THREE.BufferAttribute(targetAction, 3));
            geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

            uniforms = {
                u_time: { value: 0.0 },
                u_color: { value: MODE_COLORS[MODES.HUMANOID].clone() },
                u_progress: { value: 0.0 },
                u_mode: { value: MODES.HUMANOID }, // 0-4 for mode selection
                // Sensor uniforms
                u_temperature: { value: 0.0 },
                u_humidity: { value: 0.0 },
                u_motion: { value: 0.0 },
                u_audio_level: { value: 0.0 },
                u_object_count: { value: 0.0 },
                u_mouse: { value: new THREE.Vector2(-10, -10) },
                u_pulse: { value: 0.0 }
            };

            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: `
                    uniform float u_time;
                    uniform float u_progress;
                    uniform float u_mode; // 0=HUMANOID, 1=SPATIAL, 2=RF, 3=NEURAL, 4=ACTION
                    uniform vec2 u_mouse;
                    uniform float u_pulse;
                    uniform float u_temperature;
                    uniform float u_humidity;
                    uniform float u_motion;
                    uniform float u_audio_level;
                    uniform float u_object_count;

                    attribute vec3 aTargetHumanoid;
                    attribute vec3 aTargetSpatial;
                    attribute vec3 aTargetRF;
                    attribute vec3 aTargetNeural;
                    attribute vec3 aTargetAction;
                    attribute float aRandom;

                    // Simplex noise function
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                    float snoise(vec3 v) {
                        const vec2  C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i  = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute(permute(permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0))
                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        float n_ = 0.142857142857;
                        vec3  ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ * ns.x + ns.yyyy;
                        vec4 y = y_ * ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        vec4 s0 = floor(b0) * 2.0 + 1.0;
                        vec4 s1 = floor(b1) * 2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
                        p0 *= norm.x;
                        p1 *= norm.y;
                        p2 *= norm.z;
                        p3 *= norm.w;
                        vec4 m = max(0.51 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
                        m = m * m;
                        return 105.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
                    }

                    void main() {
                        float t = u_time * 0.2 + aRandom * 10.0;

                        // Select target position based on mode
                        vec3 targetPos = aTargetHumanoid; // Default

                        if (u_mode < 0.5) {
                            targetPos = aTargetHumanoid; // HUMANOID
                        } else if (u_mode < 1.5) {
                            targetPos = aTargetSpatial; // SPATIAL
                        } else if (u_mode < 2.5) {
                            targetPos = aTargetRF; // RF_SPECTRUM
                        } else if (u_mode < 3.5) {
                            targetPos = aTargetNeural; // NEURAL_NETWORK
                        } else {
                            targetPos = aTargetAction; // ACTION_SPACE
                        }

                        // Apply noise for organic movement
                        vec3 noisePos = vec3(targetPos * 5.0 + t);
                        float displacement = snoise(noisePos) * 0.03;

                        // Sensor-driven effects
                        float tempEffect = u_temperature * 0.05;
                        displacement += tempEffect * snoise(noisePos * 2.0);

                        float clusterEffect = u_humidity * 0.03;
                        vec3 centerPull = -normalize(targetPos + 0.001) * clusterEffect;

                        float turbulence = u_motion * snoise(noisePos * 8.0 + u_time) * 0.08;
                        displacement += turbulence;

                        float audioWave = sin(length(targetPos) * 10.0 - u_time * 5.0) * u_audio_level * 0.05;
                        displacement += audioWave;

                        float pulseEffect = u_pulse * 0.02;
                        displacement += pulseEffect;

                        vec3 noisyTargetPos = targetPos + normalize(targetPos + 0.001) * displacement + centerPull;

                        // Animate from start to target
                        float progress = smoothstep(0.0, 1.0, u_progress);
                        vec3 animatedPos = mix(position, noisyTargetPos, progress);

                        // Mouse repulsion
                        vec4 mvPosition = modelViewMatrix * vec4(animatedPos, 1.0);
                        vec2 screenPos = (mvPosition.xy / mvPosition.w);
                        float mouseDist = distance(screenPos, u_mouse);
                        float maxDist = 0.2;
                        if (mouseDist < maxDist) {
                            float pushForce = (maxDist - mouseDist) * 0.5;
                            animatedPos += normalize(animatedPos) * pushForce;
                        }

                        mvPosition = modelViewMatrix * vec4(animatedPos, 1.0);

                        // Point size
                        float sensorSize = u_pulse * 0.5 + u_audio_level * 0.3 + u_motion * 0.2;
                        float pointSize = (0.5 + aRandom * 1.5 + sensorSize);
                        gl_PointSize = (1.0 / -mvPosition.z) * pointSize;

                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 u_color;
                    uniform float u_temperature;
                    uniform float u_humidity;

                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                        if (alpha < 0.01) discard;

                        vec3 finalColor = u_color;

                        // Temperature color shift
                        float tempWarmth = u_temperature;
                        vec3 warmShift = vec3(tempWarmth * 0.3, tempWarmth * 0.1, -tempWarmth * 0.2);
                        finalColor = clamp(finalColor + warmShift, 0.0, 1.0);

                        // Humidity intensity
                        float intensityMod = 1.0 - (u_humidity * 0.2);
                        finalColor *= intensityMod;

                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true
            });

            particles = new THREE.Points(geometry, shaderMaterial);
            scene.add(particles);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onKeyPress(event) {
            const controlsDiv = document.getElementById('controls');

            switch(event.key) {
                case ' ':
                    // Space: Reconnect WebSocket
                    connectWebSocket();
                    break;
                case 'h':
                case 'H':
                    // H: Toggle help display
                    controlsDiv.style.display = controlsDiv.style.display === 'none' ? 'block' : 'none';
                    break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ========================================
        // MEMORY MANAGEMENT & CLEANUP
        // ========================================

        function cleanup() {
            console.log("Cleaning up resources...");

            // Dispose of particle system
            if (particles) {
                if (particles.geometry) {
                    particles.geometry.dispose();
                }
                if (particles.material) {
                    particles.material.dispose();
                }
                scene.remove(particles);
                particles = null;
            }

            // Close WebSocket connection
            if (ws) {
                ws.close(1000, "Page unload"); // Normal closure
                ws = null;
            }

            // Dispose of renderer
            if (renderer) {
                renderer.dispose();
                renderer = null;
            }

            console.log("✓ Resources cleaned up");
        }

        // Register cleanup on page unload
        window.addEventListener('beforeunload', cleanup);
        window.addEventListener('unload', cleanup);

        function animate() {
            requestAnimationFrame(animate);

            if (uniforms) {
                uniforms.u_time.value += 0.01;
                uniforms.u_pulse.value = (1.0 + Math.sin(uniforms.u_time.value * 4.0)) * 0.5;

                if (uniforms.u_progress.value < 1.0) {
                    uniforms.u_progress.value += 0.003;
                }

                // Smooth mode transition
                const modeSpeed = 0.02;
                uniforms.u_mode.value += (targetMode - uniforms.u_mode.value) * modeSpeed;

                uniforms.u_mouse.value.lerp(mouse, 0.1);
                uniforms.u_color.value.lerp(targetColor, 0.05);

                // Update sensor uniforms
                if (sensorData.temperature !== null) {
                    let tempNorm = Math.max(0, Math.min(1, sensorData.temperature / 40.0));
                    uniforms.u_temperature.value += (tempNorm - uniforms.u_temperature.value) * 0.05;
                } else {
                    uniforms.u_temperature.value *= 0.95;
                }

                if (sensorData.humidity !== null) {
                    let humidNorm = Math.max(0, Math.min(1, sensorData.humidity / 100.0));
                    uniforms.u_humidity.value += (humidNorm - uniforms.u_humidity.value) * 0.05;
                } else {
                    uniforms.u_humidity.value *= 0.95;
                }

                let targetMotion = sensorData.motion ? 1.0 : 0.0;
                uniforms.u_motion.value += (targetMotion - uniforms.u_motion.value) * 0.1;

                uniforms.u_audio_level.value += (sensorData.audioLevel - uniforms.u_audio_level.value) * 0.2;
                uniforms.u_object_count.value += (sensorData.objectsDetected - uniforms.u_object_count.value) * 0.05;
            }

            controls.update();
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
