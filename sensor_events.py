#!/usr/bin/env python3
"""
Sentient Core - Standardized Sensor Event Structure
Foundation for multi-modal sensor fusion and future LLM integration.
"""

import time
from typing import Dict, Any, Optional, List
from enum import Enum
from dataclasses import dataclass, field, asdict


class EventType(Enum):
    """Standardized event types for multi-modal fusion."""

    # RF & Communication Events
    RF_SIGNAL = "RF_Signal"
    RF_JAM = "RF_Jam"
    WIFI_DETECTED = "WiFi_Detected"
    BLUETOOTH_DETECTED = "Bluetooth_Detected"

    # Vision Events
    MOTION_DETECTED = "Motion_Detected"
    OBJECT_DETECTED = "Object_Detected"
    FACE_DETECTED = "Face_Detected"
    DRONE_DETECTED = "Drone_Detected"

    # Environmental Events
    TEMPERATURE_ANOMALY = "Temperature_Anomaly"
    PRESSURE_CHANGE = "Pressure_Change"
    AIR_QUALITY_ALERT = "Air_Quality_Alert"

    # Power Events
    BATTERY_LOW = "Battery_Low"
    POWER_LOSS = "Power_Loss"

    # Threat Events
    THREAT_DETECTED = "Threat_Detected"
    INTRUSION_DETECTED = "Intrusion_Detected"
    DRONE_THREAT = "Drone_Threat"

    # System Events
    DAEMON_ERROR = "Daemon_Error"
    HARDWARE_FAULT = "Hardware_Fault"


class ThreatLevel(Enum):
    """Threat severity classification."""
    NONE = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4


@dataclass
class SensorEvent:
    """
    Standardized sensor event structure for multi-modal fusion.

    This is the universal format for all sensor events across the system.
    Future LLM integration will consume events in this format.
    """

    # Core identification
    source: str  # e.g., "FlipperZero", "Camera", "BME680"
    event_type: EventType  # Standardized event type
    timestamp: float = field(default_factory=time.time)

    # Event data (sensor-specific)
    data: Dict[str, Any] = field(default_factory=dict)

    # Threat assessment (for security events)
    threat_level: ThreatLevel = ThreatLevel.NONE
    threat_description: Optional[str] = None

    # Context information
    location: Optional[Dict[str, float]] = None  # lat, lon, alt
    confidence: float = 1.0  # 0.0-1.0

    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """Convert event to dictionary for JSON serialization."""
        d = asdict(self)
        d['event_type'] = self.event_type.value
        d['threat_level'] = self.threat_level.value
        return d

    def is_threat(self) -> bool:
        """Check if this event represents a threat."""
        return self.threat_level.value >= ThreatLevel.MEDIUM.value

    def requires_action(self) -> bool:
        """Check if this event requires immediate action."""
        return self.threat_level.value >= ThreatLevel.HIGH.value

    def __repr__(self) -> str:
        return (
            f"SensorEvent(source={self.source}, type={self.event_type.value}, "
            f"threat={self.threat_level.name}, confidence={self.confidence:.2f})"
        )


@dataclass
class DroneDetectionEvent(SensorEvent):
    """Specialized event for drone detection (multi-modal fusion)."""

    def __init__(
        self,
        source: str,
        frequency: Optional[str] = None,
        signal_strength: Optional[float] = None,
        visual_detection: bool = False,
        drone_type: Optional[str] = None,
        estimated_distance: Optional[float] = None,
        **kwargs
    ):
        super().__init__(
            source=source,
            event_type=EventType.DRONE_THREAT,
            threat_level=ThreatLevel.HIGH,
            **kwargs
        )

        self.data = {
            "frequency": frequency,
            "signal_strength": signal_strength,
            "visual_detection": visual_detection,
            "drone_type": drone_type,
            "estimated_distance": estimated_distance,
            "detection_method": []
        }

        # Multi-modal fusion tracking
        if frequency:
            self.data["detection_method"].append("RF")
        if visual_detection:
            self.data["detection_method"].append("Vision")


@dataclass
class ActionCommand:
    """
    Standardized action command structure.

    This is what the LLM will generate in Phase 2 to command hardware.
    In Phase 1, these are generated by reflex logic.
    """

    target_daemon: str  # Which daemon should execute this
    action: str  # Action to perform (e.g., "jam", "track", "alert")
    parameters: Dict[str, Any] = field(default_factory=dict)
    priority: int = 5  # 1-10, higher = more urgent
    timeout: Optional[float] = None  # Max execution time in seconds
    timestamp: float = field(default_factory=time.time)

    # Phase tracking
    generated_by: str = "reflex"  # "reflex" or "llm" or "user"
    reasoning: Optional[str] = None  # LLM's reasoning (Phase 2)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return asdict(self)

    def __repr__(self) -> str:
        return (
            f"ActionCommand(target={self.target_daemon}, action={self.action}, "
            f"priority={self.priority}, by={self.generated_by})"
        )


# Drone defense frequency database
DRONE_FREQUENCIES = {
    "2.4GHz": {
        "frequency_mhz": 2400,
        "bandwidth": 100,
        "common_drones": ["DJI Phantom", "DJI Mavic", "Generic consumer drones"],
        "protocol": "WiFi-based"
    },
    "5.8GHz": {
        "frequency_mhz": 5800,
        "bandwidth": 200,
        "common_drones": ["FPV racing drones", "DJI FPV", "Custom builds"],
        "protocol": "Analog/Digital FPV"
    },
    "433MHz": {
        "frequency_mhz": 433,
        "bandwidth": 1,
        "common_drones": ["Long-range control", "Telemetry"],
        "protocol": "RC control"
    },
    "915MHz": {
        "frequency_mhz": 915,
        "bandwidth": 2,
        "common_drones": ["Long-range telemetry", "US ISM band"],
        "protocol": "LoRa/RC"
    }
}


def create_rf_event(
    source: str,
    frequency: str,
    signal_strength: float,
    is_drone_frequency: bool = False
) -> SensorEvent:
    """
    Factory function to create RF signal events with intelligent threat classification.

    Threat Classification Logic:
    - CRITICAL (-30 dBm or stronger): Drone is very close, immediate threat
    - HIGH (-40 to -30 dBm): Drone is nearby, requires analysis
    - MEDIUM (-60 to -40 dBm): Drone detected at moderate distance
    - LOW (-80 to -60 dBm): Weak signal, monitoring only
    - NONE: Below -80 dBm or not a drone frequency

    Args:
        source: Sensor name (e.g., "FlipperZero")
        frequency: Frequency string (e.g., "2.4GHz")
        signal_strength: Signal strength in dBm
        is_drone_frequency: Whether this matches known drone frequencies

    Returns:
        SensorEvent with appropriate threat level
    """
    threat = ThreatLevel.NONE
    threat_desc = None

    if is_drone_frequency:
        if signal_strength > -30:  # CRITICAL - Very close drone
            threat = ThreatLevel.CRITICAL
            threat_desc = f"CRITICAL: Drone signal {signal_strength:.1f} dBm on {frequency} - Immediate threat"
        elif signal_strength > -40:  # HIGH - Close drone, needs analysis
            threat = ThreatLevel.HIGH
            threat_desc = f"HIGH: Strong drone signal {signal_strength:.1f} dBm on {frequency}"
        elif signal_strength > -60:  # MEDIUM - Moderate distance
            threat = ThreatLevel.MEDIUM
            threat_desc = f"MEDIUM: Moderate drone signal {signal_strength:.1f} dBm on {frequency}"
        elif signal_strength > -80:  # LOW - Distant
            threat = ThreatLevel.LOW
            threat_desc = f"LOW: Weak drone signal {signal_strength:.1f} dBm on {frequency}"

    return SensorEvent(
        source=source,
        event_type=EventType.RF_SIGNAL,
        data={
            "frequency": frequency,
            "signal_strength": signal_strength,
            "is_drone_frequency": is_drone_frequency,
            "estimated_distance_meters": _estimate_distance_from_rssi(signal_strength)
        },
        threat_level=threat,
        threat_description=threat_desc
    )


def _estimate_distance_from_rssi(rssi: float) -> Optional[float]:
    """
    Estimate distance to drone based on RSSI.

    Rough approximation using free-space path loss formula.
    Actual distance varies based on environment, antenna, etc.

    Args:
        rssi: Signal strength in dBm

    Returns:
        Estimated distance in meters, or None if too weak
    """
    if rssi > -30:
        return 10.0  # Very close
    elif rssi > -40:
        return 25.0  # Close
    elif rssi > -50:
        return 50.0  # Moderate
    elif rssi > -60:
        return 100.0  # Distant
    elif rssi > -70:
        return 200.0  # Very distant
    else:
        return None  # Too far or too weak to estimate


def create_jam_command(
    frequency: str,
    duration: float = 10.0,
    power: str = "high"
) -> ActionCommand:
    """
    Factory function to create RF jamming commands.

    Args:
        frequency: Target frequency to jam
        duration: Jam duration in seconds
        power: Jam power level ("low", "medium", "high")

    Returns:
        ActionCommand for Flipper daemon
    """
    return ActionCommand(
        target_daemon="flipper",
        action="jam",
        parameters={
            "frequency": frequency,
            "duration": duration,
            "power": power
        },
        priority=9,  # High priority for active defense
        generated_by="reflex",  # Phase 1: reflex-based
        reasoning="Immediate countermeasure to drone threat"
    )


# Example usage and testing
if __name__ == "__main__":
    print("=" * 70)
    print("SENSOR EVENT SYSTEM - STRUCTURE TEST")
    print("=" * 70)

    # Test 1: Basic RF signal event
    print("\n[TEST 1] RF Signal Event:")
    rf_event = create_rf_event(
        source="FlipperZero",
        frequency="2.4GHz",
        signal_strength=-35,
        is_drone_frequency=True
    )
    print(rf_event)
    print(f"  Is threat: {rf_event.is_threat()}")
    print(f"  Requires action: {rf_event.requires_action()}")

    # Test 2: Drone detection event (multi-modal)
    print("\n[TEST 2] Drone Detection Event (Multi-Modal):")
    drone_event = DroneDetectionEvent(
        source="MultiModal",
        frequency="2.4GHz",
        signal_strength=-30,
        visual_detection=True,
        drone_type="DJI Phantom",
        estimated_distance=50.0,
        confidence=0.95
    )
    print(drone_event)
    print(f"  Detection methods: {drone_event.data['detection_method']}")

    # Test 3: Jam command
    print("\n[TEST 3] Jamming Action Command:")
    jam_cmd = create_jam_command(
        frequency="2.4GHz",
        duration=15.0,
        power="high"
    )
    print(jam_cmd)
    print(f"  Generated by: {jam_cmd.generated_by}")
    print(f"  Priority: {jam_cmd.priority}/10")

    # Test 4: Event to dict (for JSON)
    print("\n[TEST 4] Event Serialization:")
    event_dict = drone_event.to_dict()
    print(f"  Keys: {list(event_dict.keys())}")
    print(f"  Event type: {event_dict['event_type']}")

    print("\n" + "=" * 70)
    print("✓ Sensor event structure validated!")
    print("=" * 70)
